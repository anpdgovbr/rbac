# ‚ùì FAQ ‚Äî RBAC ANPD: Perguntas Frequentes

Nota: veja tamb√©m `docs/README.md` para a consolida√ß√£o das features DONE/TODO e prioridades por pacote.

[![Status](https://img.shields.io/badge/Status-Atualizado-green.svg)]()
[![Vers√£o](https://img.shields.io/badge/Vers√£o-Setembro_2025-blue.svg)]()

## üìã √çndice de Perguntas

- [üöÄ Introdu√ß√£o e Conceitos](#-introdu√ß√£o-e-conceitos)
- [üîß Instala√ß√£o e Configura√ß√£o](#-instala√ß√£o-e-configura√ß√£o)
- [üí° Uso Pr√°tico](#-uso-pr√°tico)
- [üèóÔ∏è Arquitetura e Design](#Ô∏è-arquitetura-e-design)
- [üîç Troubleshooting](#-troubleshooting)
- [üöÄ Performance e Otimiza√ß√£o](#-performance-e-otimiza√ß√£o)
- [üîê Seguran√ßa](#-seguran√ßa)
- [üîÑ Migra√ß√£o e Integra√ß√£o](#-migra√ß√£o-e-integra√ß√£o)

---

## üöÄ Introdu√ß√£o e Conceitos

### ‚ùì **O que √© o RBAC ANPD e por que foi criado?**

O RBAC ANPD √© um sistema modular de **Role-Based Access Control** (controle de acesso baseado em pap√©is) desenvolvido pela Divis√£o de Desenvolvimento e Sustenta√ß√£o de Sistemas (DDSS/CGTI/ANPD).

**Por que foi criado:**

- üéØ **Unifica√ß√£o**: Padronizar o modelo de permiss√µes `{acao, recurso}` em todos os sistemas da ANPD
- üîÑ **Reutiliza√ß√£o**: Evitar reimplementa√ß√£o de l√≥gica de autoriza√ß√£o em cada projeto
- üîí **Consist√™ncia**: Eliminar diverg√™ncias entre autoriza√ß√µes de UI e servidor
- üìà **Escalabilidade**: Suportar hierarquias complexas de perfis e alta concorr√™ncia

### ‚ùì **Qual a diferen√ßa entre `Action` e `Resource`?**

```typescript
// Action: O que o usu√°rio quer fazer
type Action = "Criar" | "Exibir" | "Editar" | "Excluir" | "Administrar"

// Resource: Em que entidade/contexto
type Resource = "Usuario" | "Processo" | "Relatorio" | "Dashboard"

// Permiss√£o completa
const permissao = { acao: "Editar", recurso: "Usuario" }
```

**Exemplos pr√°ticos:**

- `{ acao: "Exibir", recurso: "Dashboard" }` ‚Üí Pode ver o dashboard
- `{ acao: "Criar", recurso: "Processo" }` ‚Üí Pode criar novos processos
- `{ acao: "Administrar", recurso: "Usuarios" }` ‚Üí Pode gerenciar usu√°rios (super permiss√£o)

### ‚ùì **Como funciona a hierarquia de perfis?**

O sistema suporta **hierarquias DAG** (Directed Acyclic Graph):

```mermaid
graph TD
    A[Administrador] --> B[Moderador]
    A --> C[Editor]
    B --> D[Usuario]
    C --> D
```

**Regras de heran√ßa:**

- ‚úÖ **Uni√£o por Grant**: `true` sempre prevalece sobre `false`
- ‚úÖ **BFS Traversal**: Busca em largura para resolver hierarquia
- ‚úÖ **Cycle Prevention**: Preven√ß√£o autom√°tica de loops infinitos
- ‚úÖ **Active Only**: Apenas perfis ativos s√£o considerados

---

## üîß Instala√ß√£o e Configura√ß√£o

### ‚ùì **Como instalo apenas o que preciso?**

O sistema √© **modular**. Instale apenas os packages necess√°rios:

```bash
# Apenas tipos b√°sicos (0 depend√™ncias)
npm install @anpdgovbr/rbac-core

# + Provider abstraction
npm install @anpdgovbr/rbac-provider

# + Prisma ORM integration
npm install @anpdgovbr/rbac-prisma

# + Next.js middleware
npm install @anpdgovbr/rbac-next

# + React hooks/components (React 19+ required)
npm install @anpdgovbr/rbac-react

# + Admin interface (WIP)
npm install @anpdgovbr/rbac-admin
```

### ‚ùì **Preciso usar Prisma obrigatoriamente?**

**N√£o!** O Prisma √© apenas um dos providers dispon√≠veis:

```typescript
// Provider Prisma (recomendado)
import { createPrismaPermissionsProvider } from "@anpdgovbr/rbac-prisma"

// Provider customizado
class CustomProvider implements PermissionsProvider {
  async getUserPermissions(identity: string): Promise<PermissionsMap> {
    // Sua l√≥gica aqui (Redis, MongoDB, API externa, etc.)
    return permissionsMap
  }
}

// Provider in-memory (desenvolvimento/testes)
const testProvider = {
  async getUserPermissions() {
    return { "Exibir:Dashboard": true, "Criar:Usuario": false }
  },
}
```

### ‚ùì **Como configuro o cache TTL?**

```typescript
import { withTTLCache } from "@anpdgovbr/rbac-provider"

// Cache b√°sico (1 minuto)
const cachedProvider = withTTLCache(prismaProvider, 60_000)

// Cache avan√ßado com m√©tricas
const advancedCache = withTTLCache(
  prismaProvider,
  300_000, // 5 minutos
  {
    metrics: {
      onHit: (identity) => console.log(`Cache hit: ${identity}`),
      onMiss: (identity) => console.log(`Cache miss: ${identity}`),
    },
    maxSize: 1000,
    invalidateOn: ["role-updated", "permission-changed"],
  }
)

// Invalida√ß√£o manual
await cachedProvider.invalidate("user@example.com")
await cachedProvider.invalidateAll()
```

---

## üí° Uso Pr√°tico

### ‚ùì **Como protejo uma rota de API no Next.js?**

```typescript
// app/api/users/route.ts
import { withApi } from "@anpdgovbr/rbac-next"
import { NextResponse } from "next/server"

export const GET = withApi(
  async (context) => {
    // context.userId, context.audit dispon√≠veis
    const users = await getUsers()
    return NextResponse.json(users)
  },
  {
    provider: cachedPrismaProvider,
    getIdentity: nextAuthResolver,
    permissao: { acao: "Exibir", recurso: "Usuarios" },
    audit: auditLogger, // opcional
  }
)
```

### ‚ùì **Como uso no React com hooks?**

```typescript
import { usePode, usePermissions } from '@anpdgovbr/rbac-react'

function UserDashboard() {
  const { pode, loading } = usePode()
  const { permissions } = usePermissions()

  if (loading) return <Skeleton />

  return (
    <div>
      {pode("Exibir", "Relatorios") && <RelatariosSection />}
      {pode("Criar", "Usuario") && <CreateUserButton />}
      {pode("Administrar", "Sistema") && <AdminPanel />}
    </div>
  )
}
```

### ‚ùì **Como protejo um componente inteiro?**

```typescript
import { withPermissao } from '@anpdgovbr/rbac-react'

// Componente protegido
const AdminPanel = () => <div>Painel Admin Sens√≠vel</div>

// Prote√ß√£o declarativa
const ProtectedAdminPanel = withPermissao(
  AdminPanel,
  "Acessar",
  "PainelAdmin",
  {
    fallback: <AccessDenied />,
    loading: <LoadingSpinner />
  }
)
```

### ‚ùì **Como verifico m√∫ltiplas permiss√µes (OR l√≥gico)?**

```typescript
import { hasAny } from '@anpdgovbr/rbac-core'

// Qualquer uma das permiss√µes √© suficiente
const canAccessDashboard = hasAny(userPermissions, [
  { acao: "Exibir", recurso: "Dashboard" },
  { acao: "Acessar", recurso: "PainelAdmin" },
  { acao: "Visualizar", recurso: "Metricas" }
])

// React Hook version
function Dashboard() {
  const { permissions } = usePermissions()

  const canAccess = hasAny(permissions, [
    { acao: "Exibir", recurso: "Dashboard" },
    { acao: "Administrar", recurso: "Sistema" }
  ])

  if (!canAccess) return <AccessDenied />
  return <DashboardContent />
}
```

---

## üèóÔ∏è Arquitetura e Design

### ‚ùì **Por que usar monorepo em vez de um package √∫nico?**

**Vantagens do monorepo:**

- üéØ **Modularidade**: Use apenas o que precisa
- üöÄ **Zero Dependencies**: Core package n√£o tem depend√™ncias
- üîÑ **Evolu√ß√£o Coordenada**: Mudan√ßas s√≠ncronas entre packages
- üì¶ **Publica√ß√£o Independente**: Cada package tem seu ciclo de vida
- üß™ **Testing**: Testes isolados por responsabilidade

```typescript
// Projeto simples: apenas core
import { pode } from "@anpdgovbr/rbac-core"

// Projeto React: core + react
import { usePode } from "@anpdgovbr/rbac-react"

// Projeto Next.js full: core + provider + prisma + next + react
import { withApi } from "@anpdgovbr/rbac-next"
```

### ‚ùì **Como o sistema evita acoplamento com frameworks?**

**Invers√£o de Depend√™ncia:**

```typescript
// Core √© agn√≥stico de framework
type Action = string  // N√£o depende de enums espec√≠ficos
type Resource = string

// Adapters injetam depend√™ncias
interface PermissionsProvider {
  getUserPermissions(identity: string): Promise<PermissionsMap>
}

interface IdentityResolver<TRequest = unknown> {
  getIdentity(req: TRequest): Promise<string | null>
}

// Frameworks s√£o adapters opcionais
const nextAuthResolver: IdentityResolver<NextRequest> = { ... }
const customJWTResolver: IdentityResolver<Request> = { ... }
```

### ‚ùì **Como contribuir com um novo framework adapter?**

1. **Implemente os contratos base**:

```typescript
// packages/rbac-express/src/index.ts
import { PermissionsProvider, IdentityResolver } from "@anpdgovbr/rbac-provider"
import { Request, Response } from "express"

export const withExpressAuth = (
  handler: (req: Request, res: Response) => void,
  config: {
    provider: PermissionsProvider
    getIdentity: IdentityResolver<Request>
    permissao: Permissao
  }
) => {
  return async (req: Request, res: Response) => {
    // Implementa√ß√£o espec√≠fica do Express
  }
}
```

2. **Siga o padr√£o de packages existentes**
3. **Adicione testes e documenta√ß√£o**
4. **Abra PR no monorepo**

---

## üîç Troubleshooting

### ‚ùì **"Permission denied" mesmo com perfil correto**

**Poss√≠veis causas:**

1. **Cache TTL desatualizado**:

```typescript
// Force cache refresh
await cachedProvider.invalidate(userEmail)
```

2. **Perfil inativo na hierarquia**:

```sql
-- Verifique se todos os perfis da cadeia est√£o ativos
SELECT p.nome, p.ativo, ph.perfil_pai_id
FROM Perfil p
LEFT JOIN PerfilHierarquia ph ON p.id = ph.perfil_filho_id
WHERE p.id IN (/* IDs dos perfis do usu√°rio */)
```

3. **Grant falso sobrescrevendo verdadeiro**:

```typescript
// Debug permiss√µes
import { debugPermissions } from "@anpdgovbr/rbac-core"
debugPermissions(userPermissions, { showDenied: true })
```

4. **Identity resolver retornando null**:

```typescript
const identity = await getIdentity(req)
console.log("Resolved identity:", identity) // Deve retornar email/ID v√°lido
```

### ‚ùì **Performance lenta nas verifica√ß√µes de permiss√£o**

**Solu√ß√µes de otimiza√ß√£o:**

1. **Ative cache TTL**:

```typescript
const cachedProvider = withTTLCache(provider, 300_000) // 5 min
```

2. **Otimize queries Prisma**:

```typescript
// Use includes seletivos
const provider = createPrismaPermissionsProvider({
  prisma,
  queryOptimization: {
    includeRoleHierarchy: true,
    batchSize: 50,
    useIndexes: ["usuario_email_idx", "perfil_ativo_idx"],
  },
})
```

3. **Monitore performance**:

```typescript
const monitoredProvider = withMetrics(cachedProvider, {
  onPermissionCheck: (identity, action, resource, result, duration) => {
    if (duration > 100) {
      console.warn(`Slow permission check: ${duration}ms`)
    }
  },
})
```

### ‚ùì **Erro "Cannot read property of undefined" no React**

**Causa comum**: Provider n√£o configurado corretamente.

```typescript
// ‚ùå Incorreto: hook usado fora do provider
function App() {
  const { pode } = usePode() // Erro!
  return <div>...</div>
}

// ‚úÖ Correto: Provider wrapper
function App() {
  return (
    <PermissionsProvider fetcher={fetchPermissions}>
      <Dashboard /> {/* Hooks funcionam aqui */}
    </PermissionsProvider>
  )
}
```

### ‚ùì **TypeScript reclama de tipos incompat√≠veis**

**Solu√ß√£o**: Atualize para vers√µes compat√≠veis:

```json
{
  "dependencies": {
    "@anpdgovbr/rbac-react": "^0.2.0-beta.1",
    "react": "^19.0.0",
    "typescript": "^5.9.0"
  }
}
```

---

## üöÄ Performance e Otimiza√ß√£o

### ‚ùì **Qual o melhor TTL para cache de permiss√µes?**

**Recomenda√ß√µes por contexto:**

```typescript
// Desenvolvimento: cache curto para mudan√ßas frequentes
const devCache = withTTLCache(provider, 30_000) // 30 segundos

// Produ√ß√£o: balance entre performance e consist√™ncia
const prodCache = withTTLCache(provider, 300_000) // 5 minutos

// Alta concorr√™ncia: cache longo com invalida√ß√£o manual
const highConcurrencyCache = withTTLCache(
  provider,
  900_000, // 15 minutos
  {
    invalidateOn: ["user-role-changed", "role-permission-updated"],
  }
)
```

### ‚ùì **Como otimizar para muitos usu√°rios simult√¢neos?**

1. **Cache em m√∫ltiplas camadas**:

```typescript
// Redis cache + in-memory cache
const redisProvider = createRedisPermissionsProvider({
  redis: redisClient,
  fallback: prismaProvider,
  ttl: 3600, // 1 hora
})

const memoryCache = withTTLCache(redisProvider, 300_000) // 5 min
```

2. **Batch queries no Prisma**:

```typescript
const batchProvider = createPrismaPermissionsProvider({
  prisma,
  batching: {
    enabled: true,
    maxBatchSize: 100,
    batchInterval: 50, // ms
  },
})
```

3. **Preload comum permissions**:

```typescript
// Precarrega permiss√µes mais comuns
await Promise.all(
  ["Exibir:Dashboard", "Criar:Usuario", "Exibir:Relatorios"].map((key) =>
    cachedProvider.preload(key)
  )
)
```

### ‚ùì **Como medir performance do sistema RBAC?**

```typescript
import { withMetrics } from "@anpdgovbr/rbac-provider"

const metricsProvider = withMetrics(cachedProvider, {
  onPermissionCheck: (identity, action, resource, result, duration) => {
    // M√©tricas customizadas
    metrics.histogram("rbac.check.duration", duration, {
      action,
      resource,
      result: result.toString(),
    })

    metrics.increment("rbac.checks.total")

    if (duration > 100) {
      metrics.increment("rbac.checks.slow")
    }
  },

  onCacheHit: (identity) => {
    metrics.increment("rbac.cache.hits")
  },

  onCacheMiss: (identity) => {
    metrics.increment("rbac.cache.misses")
  },
})

// Dashboard de m√©tricas
// - Lat√™ncia P95 das verifica√ß√µes
// - Cache hit ratio
// - Queries mais lentas
// - Permiss√µes mais verificadas
```

---

## üîê Seguran√ßa

### ‚ùì **O cache de permiss√µes √© seguro?**

**Sim, com as devidas precau√ß√µes:**

1. **Isolamento por usu√°rio**: Cada identity tem cache separado
2. **TTL configur√°vel**: Reduz janela de inconsist√™ncia
3. **Invalida√ß√£o manual**: Mudan√ßas administrativas invalidam cache
4. **No sensitive data**: Apenas boolean grants s√£o cacheados

```typescript
// Cache seguro com invalida√ß√£o autom√°tica
const secureCache = withTTLCache(
  provider,
  300_000, // 5 min m√°ximo
  {
    // Invalida√ß√£o em mudan√ßas cr√≠ticas
    invalidateOn: ["user-deactivated", "role-permissions-changed", "hierarchy-updated"],

    // M√©tricas de seguran√ßa
    onInvalidation: (reason, identity) => {
      auditLogger.log({
        type: "permission-cache-invalidated",
        identity,
        reason,
        timestamp: new Date(),
      })
    },
  }
)
```

### ‚ùì **Como proteger contra ataques de escala√ß√£o de privil√©gios?**

1. **Valida√ß√£o server-side obrigat√≥ria**:

```typescript
// ‚ùå NUNCA confie apenas no client
if (userCanEdit) {
  // Vindo do React
  await updateUser(data) // PERIGOSO!
}

// ‚úÖ SEMPRE valide no servidor
export const PUT = withApi(
  async (context) => {
    // Verifica√ß√£o autom√°tica pelo middleware
    return await updateUser(data)
  },
  {
    permissao: { acao: "Editar", recurso: "Usuario" },
  }
)
```

2. **Auditoria completa**:

```typescript
const auditLogger = async (auditData) => {
  await auditService.record({
    userId: auditData.userId,
    action: auditData.action,
    resource: auditData.resource,
    allowed: auditData.allowed,
    timestamp: auditData.timestamp,
    ip: auditData.clientIp,
    userAgent: auditData.userAgent,

    // Contexto adicional para investiga√ß√£o
    sessionId: auditData.sessionId,
    correlationId: auditData.correlationId,
  })
}
```

3. **Princ√≠pio do menor privil√©gio**:

```typescript
// ‚úÖ Permiss√µes espec√≠ficas
{ acao: "Editar", recurso: "UsuarioPropriosDados" }

// ‚ùå Permiss√µes muito amplas
{ acao: "Administrar", recurso: "*" }
```

### ‚ùì **Como implementar rate limiting por permiss√£o?**

```typescript
import { withRateLimit } from "@anpdgovbr/rbac-provider"

const rateLimitedProvider = withRateLimit(cachedProvider, {
  // Limites por a√ß√£o
  limits: {
    "Criar:Usuario": { requests: 10, window: 60_000 }, // 10/min
    "Excluir:*": { requests: 5, window: 300_000 }, // 5/5min
    "*": { requests: 1000, window: 60_000 }, // default
  },

  // A√ß√£o quando limite excedido
  onLimitExceeded: (identity, action, resource) => {
    auditLogger.log({
      type: "rate-limit-exceeded",
      identity,
      action,
      resource,
    })

    throw new TooManyRequestsError()
  },
})
```

---

## üîÑ Migra√ß√£o e Integra√ß√£o

### ‚ùì **Como migrar de um sistema legado gradualmente?**

**Estrat√©gia h√≠brida:**

```typescript
// 1. Wrapper de compatibilidade
class LegacyCompatProvider implements PermissionsProvider {
  constructor(
    private legacyAuth: LegacyAuthSystem,
    private newProvider: PermissionsProvider
  ) {}

  async getUserPermissions(identity: string): Promise<PermissionsMap> {
    // Feature flag para migra√ß√£o gradual
    if (await this.shouldUseLegacy(identity)) {
      return this.mapLegacyPermissions(await this.legacyAuth.getUserRoles(identity))
    }

    return this.newProvider.getUserPermissions(identity)
  }

  private mapLegacyPermissions(legacyRoles: string[]): PermissionsMap {
    const mapping: Record<string, Permissao[]> = {
      ADMIN: [{ acao: "Administrar", recurso: "*" }],
      USER: [{ acao: "Exibir", recurso: "Dashboard" }],
      EDITOR: [
        { acao: "Criar", recurso: "Conteudo" },
        { acao: "Editar", recurso: "Conteudo" },
      ],
    }

    const permissions: Permissao[] = []
    legacyRoles.forEach((role) => {
      permissions.push(...(mapping[role] || []))
    })

    return toPermissionsMap(permissions)
  }
}

// 2. Uso no sistema
const hybridProvider = new LegacyCompatProvider(legacyAuthSystem, newPrismaProvider)
```

### ‚ùì **Como integrar com NextAuth.js?**

```typescript
// 1. Identity resolver NextAuth
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'

const nextAuthResolver: IdentityResolver<NextRequest> = {
  async getIdentity(req) {
    const session = await getServerSession(authOptions)
    return session?.user?.email || null
  }
}

// 2. Middleware integration
export const GET = withApi(
  async (context) => {
    // context.userId ser√° o email do NextAuth
    return NextResponse.json({ user: context.userId })
  },
  {
    provider: cachedProvider,
    getIdentity: nextAuthResolver,
    permissao: { acao: "Exibir", recurso: "PerfilUsuario" }
  }
)

// 3. Client-side integration
function App() {
  return (
    <SessionProvider session={session}>
      <PermissionsProvider
        fetcher={async () => {
          const res = await fetch('/api/me/permissions')
          return res.json()
        }}
      >
        <YourApp />
      </PermissionsProvider>
    </SessionProvider>
  )
}
```

### ‚ùì **Como suportar multi-tenant?**

```typescript
// 1. Tenant-aware provider
const createTenantProvider = (basePrismaProvider: PermissionsProvider) => {
  return {
    async getUserPermissions(identity: string): Promise<PermissionsMap> {
      const tenant = extractTenantFromIdentity(identity)

      // Scope permissions by tenant
      const permissions = await basePrismaProvider.getUserPermissions(identity)

      // Filter/modify based on tenant rules
      return applyTenantFilters(permissions, tenant)
    },
  }
}

// 2. Tenant extraction
function extractTenantFromIdentity(identity: string): string {
  // Via email domain
  if (identity.endsWith("@anpd.gov.br")) return "anpd"
  if (identity.endsWith("@cliente.com")) return "cliente"

  // Via JWT claims
  const decoded = jwt.decode(identity)
  return decoded.tenant || "default"
}

// 3. Prisma with tenant filtering
const tenantProvider = createPrismaPermissionsProvider({
  prisma,
  whereClause: (identity) => {
    const tenant = extractTenantFromIdentity(identity)
    return {
      tenant_id: tenant,
      ativo: true,
    }
  },
})
```

### ‚ùì **Posso usar com outras ORMs al√©m do Prisma?**

**Sim! Exemplos de implementa√ß√£o:**

```typescript
// Sequelize Provider
class SequelizePermissionsProvider implements PermissionsProvider {
  async getUserPermissions(identity: string): Promise<PermissionsMap> {
    const user = await User.findOne({
      where: { email: identity },
      include: [{ model: Role, include: [Permission] }],
    })

    return this.buildPermissionsMap(user.Roles)
  }
}

// TypeORM Provider
class TypeORMPermissionsProvider implements PermissionsProvider {
  async getUserPermissions(identity: string): Promise<PermissionsMap> {
    const user = await this.userRepository.findOne({
      where: { email: identity },
      relations: ["roles", "roles.permissions"],
    })

    return this.buildPermissionsMap(user.roles)
  }
}

// MongoDB Provider
class MongoPermissionsProvider implements PermissionsProvider {
  async getUserPermissions(identity: string): Promise<PermissionsMap> {
    const user = await this.userCollection.aggregate([
      { $match: { email: identity } },
      { $lookup: { from: "roles", localField: "roles", foreignField: "_id" } },
      { $unwind: "$roles" },
      {
        $lookup: {
          from: "permissions",
          localField: "roles.permissions",
          foreignField: "_id",
        },
      },
    ])

    return this.buildPermissionsMap(user[0]?.roles || [])
  }
}
```

---

## üìû Suporte e Comunidade

### ‚ùì **Onde reportar bugs ou solicitar features?**

- üêõ **Issues**: Abra issue no reposit√≥rio interno
- üí° **Feature Requests**: Discussions ou diretamente com a equipe DDSS
- üìö **Documenta√ß√£o**: PRs s√£o bem-vindos para melhorias
- üí¨ **Suporte**: Equipe DDSS/CGTI/ANPD

### ‚ùì **Como contribuir com o projeto?**

1. **Fork** do reposit√≥rio
2. **Branch** feature espec√≠fica (`feature/nome-da-feature`)
3. **Testes** para mudan√ßas implementadas
4. **Documenta√ß√£o** atualizada
5. **PR** com descri√ß√£o detalhada

### ‚ùì **Roadmap de pr√≥ximas vers√µes?**

**v0.2.x (Q4 2025)**:

- ‚úÖ React 19+ migration completa
- üöß Admin interface funcional
- üìä Dashboard de analytics
- üîç Query builder visual

**v0.3.x (Q1 2026)**:

- üåê GraphQL adapter
- üöÄ Performance optimizations
- üèóÔ∏è Visual hierarchy editor
- üì± Mobile admin app

**v1.0.0 (Q2 2026)**:

- üéØ API est√°vel
- üìñ Documenta√ß√£o completa
- üîí Security audit
- üè¢ Enterprise features

---

**√öltima Atualiza√ß√£o**: Setembro 2025  
**Mantido por**: Divis√£o de Desenvolvimento e Sustenta√ß√£o de Sistemas (DDSS/CGTI/ANPD)  
**Vers√£o**: v0.1.0-beta.3 (core), v0.2.0-beta.1 (react/admin)
